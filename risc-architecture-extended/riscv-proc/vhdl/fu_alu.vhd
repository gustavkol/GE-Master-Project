-- Copyright (c) 2023 Tampere University.
-- Module generated by OpenASIP.
-- Permission is hereby granted, free of charge, to any person obtaining a
-- copy of this software and associated documentation files (the "Software"),
-- to deal in the Software without restriction, including without limitation
-- the rights to use, copy, modify, merge, publish, distribute, sublicense,
-- and/or sell copies of the Software, and to permit persons to whom the
-- Software is furnished to do so, subject to the following conditions:
-- The above copyright notice and this permission notice shall be included in
-- all copies or substantial portions of the Software.
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-- DEALINGS IN THE SOFTWARE.
-- 
-- Generated on Fri Mar  1 16:58:19 2024
-- 
-- Function Unit: ALU
-- 
-- Operations:
--  add            :  0
--  and            :  1
--  comp_term_init :  2
--  ior            :  3
--  lt             :  4
--  ltu            :  5
--  shl            :  6
--  shr            :  7
--  shru           :  8
--  sub            :  9
--  xor            : 10
-- 

library IEEE;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;
--use IEEE.Std_Logic_arith.all;

entity fu_alu is
  port (
    clk : in std_logic;
    rstx : in std_logic;
    glock_in : in std_logic;
    glockreq_out : out std_logic;
    operation_in : in std_logic_vector(4-1 downto 0);
    data_P1_in : in std_logic_vector(32-1 downto 0);
    load_P1_in : in std_logic;
    data_P2_in : in std_logic_vector(32-1 downto 0);
    load_P2_in : in std_logic;
    data_P3_out : out std_logic_vector(32-1 downto 0));
end entity fu_alu;

architecture rtl of fu_alu is

  constant op_add_c : std_logic_vector(3 downto 0) := "0000";
  constant op_and_c : std_logic_vector(3 downto 0) := "0001";
  constant op_comp_term_init_c : std_logic_vector(3 downto 0) := "0010";
  constant op_ior_c : std_logic_vector(3 downto 0) := "0011";
  constant op_lt_c : std_logic_vector(3 downto 0) := "0100";
  constant op_ltu_c : std_logic_vector(3 downto 0) := "0101";
  constant op_shl_c : std_logic_vector(3 downto 0) := "0110";
  constant op_shr_c : std_logic_vector(3 downto 0) := "0111";
  constant op_shru_c : std_logic_vector(3 downto 0) := "1000";
  constant op_sub_c : std_logic_vector(3 downto 0) := "1001";
  constant op_xor_c : std_logic_vector(3 downto 0) := "1010";

  signal add_op1 : std_logic_vector(31 downto 0);
  signal add_op2 : std_logic_vector(31 downto 0);
  signal add_op3 : std_logic_vector(31 downto 0);
  signal and_op1 : std_logic_vector(31 downto 0);
  signal and_op2 : std_logic_vector(31 downto 0);
  signal and_op3 : std_logic_vector(31 downto 0);
  signal comp_term_init_op1 : std_logic_vector(7 downto 0);
  signal comp_term_init_op2 : std_logic_vector(16 downto 0);
  signal comp_term_init_op3 : std_logic_vector(31 downto 0);
  signal ior_op1 : std_logic_vector(31 downto 0);
  signal ior_op2 : std_logic_vector(31 downto 0);
  signal ior_op3 : std_logic_vector(31 downto 0);
  signal lt_op1 : std_logic_vector(31 downto 0);
  signal lt_op2 : std_logic_vector(31 downto 0);
  signal lt_op3 : std_logic;
  signal ltu_op1 : std_logic_vector(31 downto 0);
  signal ltu_op2 : std_logic_vector(31 downto 0);
  signal ltu_op3 : std_logic;
  signal shl_op1 : std_logic_vector(31 downto 0);
  signal shl_op2 : std_logic_vector(4 downto 0);
  signal shl_op3 : std_logic_vector(31 downto 0);
  signal shr_op1 : std_logic_vector(31 downto 0);
  signal shr_op2 : std_logic_vector(4 downto 0);
  signal shr_op3 : std_logic_vector(31 downto 0);
  signal shru_op1 : std_logic_vector(31 downto 0);
  signal shru_op2 : std_logic_vector(4 downto 0);
  signal shru_op3 : std_logic_vector(31 downto 0);
  signal sub_op1 : std_logic_vector(31 downto 0);
  signal sub_op2 : std_logic_vector(31 downto 0);
  signal sub_op3 : std_logic_vector(31 downto 0);
  signal xor_op1 : std_logic_vector(31 downto 0);
  signal xor_op2 : std_logic_vector(31 downto 0);
  signal xor_op3 : std_logic_vector(31 downto 0);
  signal data_P1 : std_logic_vector(31 downto 0);
  signal data_P2 : std_logic_vector(31 downto 0);
  signal data_P3 : std_logic_vector(31 downto 0);

  signal shadow_P2_r : std_logic_vector(31 downto 0);
  signal operation_1_r : std_logic_vector(3 downto 0);
  signal optrig_1_r : std_logic;
  signal data_P3_1_r : std_logic_vector(31 downto 0);
  signal data_P3_1_valid_r : std_logic;
  signal data_P3_r : std_logic_vector(31 downto 0);

begin

  data_P1 <= data_P1_in;

  shadow_P2_sp : process(clk, rstx)
  begin
    if rstx = '0' then
      shadow_P2_r <= (others => '0');
    elsif clk = '1' and clk'event then
      if ((glock_in = '0') and (load_P2_in = '1')) then
        shadow_P2_r <= data_P2_in;
      end if;
    end if;
  end process shadow_P2_sp;

  shadow_P2_cp : process(data_P2_in, shadow_P2_r, load_P2_in, load_P1_in)
  begin
    if ((load_P1_in = '1') and (load_P2_in = '1')) then
      data_P2 <= data_P2_in;
    else
      data_P2 <= shadow_P2_r;
    end if;
  end process shadow_P2_cp;

  input_pipeline_sp : process(clk, rstx)
  begin
    if rstx = '0' then
      operation_1_r <= (others => '0');
      optrig_1_r <= '0';
    elsif clk = '1' and clk'event then
      if (glock_in = '0') then
        optrig_1_r <= load_P1_in;
        if (load_P1_in = '1') then
          operation_1_r <= operation_in;
        end if;
      end if;
    end if;
  end process input_pipeline_sp;

  operations_actual_cp : process(data_P2, add_op2, add_op1, and_op2, comp_term_init_op2, comp_term_init_op1, shl_op2, and_op1, shru_op2, ltu_op1, xor_op2, operation_in, data_P1, ior_op2, sub_op1, sub_op2, shl_op1, xor_op1, lt_op2, shr_op2, load_P1_in, shr_op1, ltu_op2, lt_op1, ior_op1, shru_op1)
  begin
    xor_op3 <= (others => '-');
    xor_op1 <= data_P1;
    xor_op2 <= data_P2;
    sub_op3 <= (others => '-');
    sub_op1 <= data_P1;
    sub_op2 <= data_P2;
    shr_op3 <= (others => '-');
    shr_op1 <= data_P1;
    shr_op2 <= data_P2(4 downto 0);
    ltu_op3 <= '-';
    ltu_op1 <= data_P1;
    ltu_op2 <= data_P2;
    lt_op3 <= '-';
    lt_op1 <= data_P1;
    lt_op2 <= data_P2;
    ior_op3 <= (others => '-');
    ior_op1 <= data_P1;
    ior_op2 <= data_P2;
    shru_op3 <= (others => '-');
    shru_op1 <= data_P1;
    shru_op2 <= data_P2(4 downto 0);
    shl_op3 <= (others => '-');
    shl_op1 <= data_P1;
    shl_op2 <= data_P2(4 downto 0);
    comp_term_init_op3 <= (others => '-');
    comp_term_init_op1 <= data_P1(7 downto 0);
    comp_term_init_op2 <= data_P2(16 downto 0);
    and_op3 <= (others => '-');
    and_op1 <= data_P1;
    and_op2 <= data_P2;
    add_op3 <= (others => '-');
    add_op1 <= data_P1;
    add_op2 <= data_P2;
    if (load_P1_in = '1') then
      case operation_in is
        when op_add_c =>
          add_op3 <= std_logic_vector(signed(add_op1) + signed(add_op2));
        when op_and_c =>
          and_op3 <= and_op1 and and_op2;
        when op_comp_term_init_c =>
          comp_term_init_op3 <= std_logic_vector(resize(signed(signed(comp_term_init_op1(7 downto 2)) * signed(comp_term_init_op2(16 downto 2))), comp_term_init_op3'length - 1)) & (0 downto 0 => '0');
        when op_ior_c =>
          ior_op3 <= ior_op1 or ior_op2;
        when op_lt_c =>
          if signed(lt_op1) < signed(lt_op2) then
            lt_op3 <= '1';
          else
            lt_op3 <= '0';
          end if;
        when op_ltu_c =>
          if unsigned(ltu_op1) < unsigned(ltu_op2) then
            ltu_op3 <= '1';
          else
            ltu_op3 <= '0';
          end if;
        when op_shl_c =>
          shl_op3 <= std_logic_vector(shift_left(unsigned(shl_op1), to_integer(unsigned(shl_op2(4 downto 0)))));
        when op_shr_c =>
          shr_op3 <= std_logic_vector(shift_right(signed(shr_op1), to_integer(unsigned(shr_op2(4 downto 0)))));
        when op_shru_c =>
          shru_op3 <= std_logic_vector(shift_right(unsigned(shru_op1), to_integer(unsigned(shru_op2(4 downto 0)))));
        when op_sub_c =>
          sub_op3 <= std_logic_vector(signed(sub_op1) - signed(sub_op2));
        when op_xor_c =>
          xor_op3 <= xor_op1 xor xor_op2;
        when others =>
      end case;
    end if;
  end process operations_actual_cp;

  output_pipeline_sp : process(clk, rstx)
  begin
    if rstx = '0' then
      data_P3_r <= (others => '0');
      data_P3_1_r <= (others => '0');
      data_P3_1_valid_r <= '0';
    elsif clk = '1' and clk'event then
      if (glock_in = '0') then
        data_P3_1_valid_r <= '1';
        if ((operation_in = op_xor_c) and (load_P1_in = '1')) then
          data_P3_1_r <= xor_op3;
        elsif ((operation_in = op_sub_c) and (load_P1_in = '1')) then
          data_P3_1_r <= sub_op3;
        elsif ((operation_in = op_shru_c) and (load_P1_in = '1')) then
          data_P3_1_r <= shru_op3;
        elsif ((operation_in = op_shr_c) and (load_P1_in = '1')) then
          data_P3_1_r <= shr_op3;
        elsif ((operation_in = op_shl_c) and (load_P1_in = '1')) then
          data_P3_1_r <= shl_op3;
        elsif ((operation_in = op_ltu_c) and (load_P1_in = '1')) then
          data_P3_1_r <= ((32-1 downto 1 => '0') & ltu_op3);
        elsif ((operation_in = op_lt_c) and (load_P1_in = '1')) then
          data_P3_1_r <= ((32-1 downto 1 => '0') & lt_op3);
        elsif ((operation_in = op_ior_c) and (load_P1_in = '1')) then
          data_P3_1_r <= ior_op3;
        elsif ((operation_in = op_comp_term_init_c) and (load_P1_in = '1')) then
          data_P3_1_r <= comp_term_init_op3;
        elsif ((operation_in = op_and_c) and (load_P1_in = '1')) then
          data_P3_1_r <= and_op3;
        elsif ((operation_in = op_add_c) and (load_P1_in = '1')) then
          data_P3_1_r <= add_op3;
        else
          data_P3_1_valid_r <= '0';
        end if;
        data_P3_r <= data_P3;
      end if;
    end if;
  end process output_pipeline_sp;

  output_pipeline_cp : process(data_P3, data_P3_1_r)
  begin
    data_P3 <= data_P3_1_r;
    data_P3_out <= data_P3;
  end process output_pipeline_cp;
  glockreq_out <= '0';

end architecture rtl;

