-- Copyright (c) 2023 Tampere University.
-- Module generated by OpenASIP.
-- Permission is hereby granted, free of charge, to any person obtaining a
-- copy of this software and associated documentation files (the "Software"),
-- to deal in the Software without restriction, including without limitation
-- the rights to use, copy, modify, merge, publish, distribute, sublicense,
-- and/or sell copies of the Software, and to permit persons to whom the
-- Software is furnished to do so, subject to the following conditions:
-- The above copyright notice and this permission notice shall be included in
-- all copies or substantial portions of the Software.
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-- DEALINGS IN THE SOFTWARE.
-- 
-- Generated on Tue Mar 12 12:44:43 2024
-- 
-- Function Unit: LSU
-- 
-- Operations:
--  ald16  : 0
--  ald32  : 1
--  ald8   : 2
--  aldu16 : 3
--  aldu8  : 4
--  ast16  : 5
--  ast32  : 6
--  ast8   : 7
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

entity fu_lsu is
  port (
    clk : in std_logic;
    rstx : in std_logic;
    glock_in : in std_logic;
    glockreq_out : out std_logic;
    operation_in : in std_logic_vector(3-1 downto 0);
    data_in1t_in : in std_logic_vector(32-1 downto 0);
    load_in1t_in : in std_logic;
    data_in2_in : in std_logic_vector(32-1 downto 0);
    load_in2_in : in std_logic;
    data_out1_out : out std_logic_vector(32-1 downto 0);
    data_in3_in : in std_logic_vector(32-1 downto 0);
    load_in3_in : in std_logic;
    avalid_out : out std_logic_vector(1-1 downto 0);
    aready_in : in std_logic_vector(1-1 downto 0);
    aaddr_out : out std_logic_vector(17-2-1 downto 0);
    awren_out : out std_logic_vector(1-1 downto 0);
    astrb_out : out std_logic_vector(4-1 downto 0);
    rvalid_in : in std_logic_vector(1-1 downto 0);
    rready_out : out std_logic_vector(1-1 downto 0);
    rdata_in : in std_logic_vector(32-1 downto 0);
    adata_out : out std_logic_vector(32-1 downto 0));
end entity fu_lsu;

architecture rtl of fu_lsu is

  constant addrw_c : integer := 17;
  constant op_ald16_c : std_logic_vector(2 downto 0) := "000";
  constant op_ald32_c : std_logic_vector(2 downto 0) := "001";
  constant op_ald8_c : std_logic_vector(2 downto 0) := "010";
  constant op_aldu16_c : std_logic_vector(2 downto 0) := "011";
  constant op_aldu8_c : std_logic_vector(2 downto 0) := "100";
  constant op_ast16_c : std_logic_vector(2 downto 0) := "101";
  constant op_ast32_c : std_logic_vector(2 downto 0) := "110";
  constant op_ast8_c : std_logic_vector(2 downto 0) := "111";

  signal ald16_op1 : std_logic_vector(31 downto 0);
  signal ald16_op2 : std_logic_vector(31 downto 0);
  signal ald16_op3 : std_logic_vector(31 downto 0);
  signal subop_add_0_op1 : std_logic_vector(31 downto 0);
  signal subop_add_0_op2 : std_logic_vector(31 downto 0);
  signal subop_add_0_op3 : std_logic_vector(31 downto 0);
  signal subop_ld16_0_op1 : std_logic_vector(63 downto 0);
  signal subop_ld16_0_op2 : std_logic_vector(31 downto 0);
  signal ald32_op1 : std_logic_vector(31 downto 0);
  signal ald32_op2 : std_logic_vector(31 downto 0);
  signal ald32_op3 : std_logic_vector(31 downto 0);
  signal subop_add_1_op1 : std_logic_vector(31 downto 0);
  signal subop_add_1_op2 : std_logic_vector(31 downto 0);
  signal subop_add_1_op3 : std_logic_vector(31 downto 0);
  signal subop_ld32_0_op1 : std_logic_vector(63 downto 0);
  signal subop_ld32_0_op2 : std_logic_vector(31 downto 0);
  signal ald8_op1 : std_logic_vector(31 downto 0);
  signal ald8_op2 : std_logic_vector(31 downto 0);
  signal ald8_op3 : std_logic_vector(31 downto 0);
  signal subop_add_2_op1 : std_logic_vector(31 downto 0);
  signal subop_add_2_op2 : std_logic_vector(31 downto 0);
  signal subop_add_2_op3 : std_logic_vector(31 downto 0);
  signal subop_ld8_0_op1 : std_logic_vector(63 downto 0);
  signal subop_ld8_0_op2 : std_logic_vector(31 downto 0);
  signal aldu16_op1 : std_logic_vector(31 downto 0);
  signal aldu16_op2 : std_logic_vector(31 downto 0);
  signal aldu16_op3 : std_logic_vector(31 downto 0);
  signal subop_add_3_op1 : std_logic_vector(31 downto 0);
  signal subop_add_3_op2 : std_logic_vector(31 downto 0);
  signal subop_add_3_op3 : std_logic_vector(31 downto 0);
  signal subop_ldu16_0_op1 : std_logic_vector(63 downto 0);
  signal subop_ldu16_0_op2 : std_logic_vector(31 downto 0);
  signal aldu8_op1 : std_logic_vector(31 downto 0);
  signal aldu8_op2 : std_logic_vector(31 downto 0);
  signal aldu8_op3 : std_logic_vector(31 downto 0);
  signal subop_add_4_op1 : std_logic_vector(31 downto 0);
  signal subop_add_4_op2 : std_logic_vector(31 downto 0);
  signal subop_add_4_op3 : std_logic_vector(31 downto 0);
  signal subop_ldu8_0_op1 : std_logic_vector(63 downto 0);
  signal subop_ldu8_0_op2 : std_logic_vector(31 downto 0);
  signal ast16_op1 : std_logic_vector(31 downto 0);
  signal ast16_op2 : std_logic_vector(31 downto 0);
  signal ast16_op3 : std_logic_vector(31 downto 0);
  signal subop_add_5_op1 : std_logic_vector(31 downto 0);
  signal subop_add_5_op2 : std_logic_vector(31 downto 0);
  signal subop_add_5_op3 : std_logic_vector(31 downto 0);
  signal subop_st16_0_op1 : std_logic_vector(31 downto 0);
  signal subop_st16_0_op2 : std_logic_vector(15 downto 0);
  signal ast32_op1 : std_logic_vector(31 downto 0);
  signal ast32_op2 : std_logic_vector(31 downto 0);
  signal ast32_op3 : std_logic_vector(31 downto 0);
  signal subop_add_6_op1 : std_logic_vector(31 downto 0);
  signal subop_add_6_op2 : std_logic_vector(31 downto 0);
  signal subop_add_6_op3 : std_logic_vector(31 downto 0);
  signal subop_st32_0_op1 : std_logic_vector(63 downto 0);
  signal subop_st32_0_op2 : std_logic_vector(31 downto 0);
  signal ast8_op1 : std_logic_vector(31 downto 0);
  signal ast8_op2 : std_logic_vector(31 downto 0);
  signal ast8_op3 : std_logic_vector(31 downto 0);
  signal subop_add_7_op1 : std_logic_vector(31 downto 0);
  signal subop_add_7_op2 : std_logic_vector(31 downto 0);
  signal subop_add_7_op3 : std_logic_vector(31 downto 0);
  signal subop_st8_0_op1 : std_logic_vector(31 downto 0);
  signal subop_st8_0_op2 : std_logic_vector(7 downto 0);
  signal lsu_registers_32_1_clk : std_logic;
  signal lsu_registers_32_1_rstx : std_logic;
  signal lsu_registers_32_1_glock_in : std_logic;
  signal lsu_registers_32_1_glockreq_out : std_logic;
  signal lsu_registers_32_1_avalid_in : std_logic;
  signal lsu_registers_32_1_awren_in : std_logic;
  signal lsu_registers_32_1_aaddr_in : std_logic_vector(addrw_c-1+1-1 downto 0);
  signal lsu_registers_32_1_astrb_in : std_logic_vector(4-1+1-1 downto 0);
  signal lsu_registers_32_1_adata_in : std_logic_vector(32-1+1-1 downto 0);
  signal lsu_registers_32_1_avalid_out : std_logic;
  signal lsu_registers_32_1_aready_in : std_logic;
  signal lsu_registers_32_1_aaddr_out : std_logic_vector(addrw_c-2-1+1-1 downto 0);
  signal lsu_registers_32_1_awren_out : std_logic;
  signal lsu_registers_32_1_astrb_out : std_logic_vector(4-1+1-1 downto 0);
  signal lsu_registers_32_1_adata_out : std_logic_vector(32-1+1-1 downto 0);
  signal lsu_registers_32_1_rvalid_in : std_logic;
  signal lsu_registers_32_1_rready_out : std_logic;
  signal lsu_registers_32_1_rdata_in : std_logic_vector(32-1+1-1 downto 0);
  signal lsu_registers_32_1_rdata_out : std_logic_vector(32-1+1-1 downto 0);
  signal lsu_registers_32_1_addr_low_out : std_logic_vector(2-1+1-1 downto 0);
  signal data_in1t : std_logic_vector(31 downto 0);
  signal data_in2 : std_logic_vector(31 downto 0);
  signal data_in3 : std_logic_vector(31 downto 0);
  signal strobe_32b : std_logic_vector(3 downto 0);
  signal write_data_32b : std_logic_vector(31 downto 0);
  signal load_data_32b : std_logic_vector(31 downto 0);
  signal data_out1 : std_logic_vector(31 downto 0);
  signal glockreq : std_logic;

  signal shadow_in2_r : std_logic_vector(31 downto 0);
  signal shadow_in3_r : std_logic_vector(31 downto 0);
  signal operation_1_r : std_logic_vector(2 downto 0);
  signal optrig_1_r : std_logic;
  signal operation_2_r : std_logic_vector(2 downto 0);
  signal optrig_2_r : std_logic;
  signal data_out1_r : std_logic_vector(31 downto 0);

  component lsu_registers is
    generic (
      dataw_g : integer;
      low_bits_g : integer;
      addrw_g : integer);
    port (
      clk : in std_logic;
      rstx : in std_logic;
      glock_in : in std_logic;
      glockreq_out : out std_logic;
      avalid_in : in std_logic;
      awren_in : in std_logic;
      aaddr_in : in std_logic_vector(addrw_c-1+1-1 downto 0);
      astrb_in : in std_logic_vector(4-1+1-1 downto 0);
      adata_in : in std_logic_vector(32-1+1-1 downto 0);
      avalid_out : out std_logic;
      aready_in : in std_logic;
      aaddr_out : out std_logic_vector(addrw_c-2-1+1-1 downto 0);
      awren_out : out std_logic;
      astrb_out : out std_logic_vector(4-1+1-1 downto 0);
      adata_out : out std_logic_vector(32-1+1-1 downto 0);
      rvalid_in : in std_logic;
      rready_out : out std_logic;
      rdata_in : in std_logic_vector(32-1+1-1 downto 0);
      rdata_out : out std_logic_vector(32-1+1-1 downto 0);
      addr_low_out : out std_logic_vector(2-1+1-1 downto 0));
  end component lsu_registers;

begin

  lsu_registers_32_1 : lsu_registers
    generic map (
      dataw_g => 32,
      low_bits_g => 2,
      addrw_g => addrw_c)
    port map (
      clk => clk,
      rstx => rstx,
      glock_in => glock_in,
      glockreq_out => lsu_registers_32_1_glockreq_out,
      avalid_in => lsu_registers_32_1_avalid_in,
      awren_in => lsu_registers_32_1_awren_in,
      aaddr_in => lsu_registers_32_1_aaddr_in,
      astrb_in => lsu_registers_32_1_astrb_in,
      adata_in => lsu_registers_32_1_adata_in,
      avalid_out => lsu_registers_32_1_avalid_out,
      aready_in => lsu_registers_32_1_aready_in,
      aaddr_out => lsu_registers_32_1_aaddr_out,
      awren_out => lsu_registers_32_1_awren_out,
      astrb_out => lsu_registers_32_1_astrb_out,
      adata_out => lsu_registers_32_1_adata_out,
      rvalid_in => lsu_registers_32_1_rvalid_in,
      rready_out => lsu_registers_32_1_rready_out,
      rdata_in => lsu_registers_32_1_rdata_in,
      rdata_out => lsu_registers_32_1_rdata_out,
      addr_low_out => lsu_registers_32_1_addr_low_out);

  data_in1t <= data_in1t_in;

  shadow_in2_sp : process(clk, rstx)
  begin
    if rstx = '0' then
      shadow_in2_r <= (others => '0');
    elsif clk = '1' and clk'event then
      if ((glock_in = '0') and (load_in2_in = '1')) then
        shadow_in2_r <= data_in2_in;
      end if;
    end if;
  end process shadow_in2_sp;

  shadow_in2_cp : process(shadow_in2_r, data_in2_in, load_in2_in, load_in1t_in)
  begin
    if ((load_in1t_in = '1') and (load_in2_in = '1')) then
      data_in2 <= data_in2_in;
    else
      data_in2 <= shadow_in2_r;
    end if;
  end process shadow_in2_cp;

  shadow_in3_sp : process(clk, rstx)
  begin
    if rstx = '0' then
      shadow_in3_r <= (others => '0');
    elsif clk = '1' and clk'event then
      if ((glock_in = '0') and (load_in3_in = '1')) then
        shadow_in3_r <= data_in3_in;
      end if;
    end if;
  end process shadow_in3_sp;

  shadow_in3_cp : process(shadow_in3_r, data_in3_in, load_in3_in, load_in1t_in)
  begin
    if ((load_in1t_in = '1') and (load_in3_in = '1')) then
      data_in3 <= data_in3_in;
    else
      data_in3 <= shadow_in3_r;
    end if;
  end process shadow_in3_cp;

  input_pipeline_sp : process(clk, rstx)
  begin
    if rstx = '0' then
      operation_1_r <= (others => '0');
      optrig_2_r <= '0';
      operation_2_r <= (others => '0');
      optrig_1_r <= '0';
    elsif clk = '1' and clk'event then
      if (glock_in = '0') then
        optrig_1_r <= load_in1t_in;
        operation_2_r <= operation_1_r;
        optrig_2_r <= optrig_1_r;
        if (load_in1t_in = '1') then
          operation_1_r <= operation_in;
        end if;
      end if;
    end if;
  end process input_pipeline_sp;

  operations_actual_cp : process(operation_2_r, operation_in, subop_ld16_0_op2, subop_ldu16_0_op2, subop_add_4_op3, subop_add_3_op3, subop_add_1_op3, subop_add_0_op3, subop_ldu8_0_op2, subop_add_5_op3, data_in3, data_in2, data_in1t, write_data_32b, ast32_op2, subop_add_5_op2, subop_ld8_0_op2, ast32_op3, lsu_registers_32_1_addr_low_out, subop_add_1_op1, subop_add_6_op2, subop_st16_0_op2, ast16_op2, subop_add_0_op1, subop_ld32_0_op2, subop_add_6_op1, subop_st32_0_op2, subop_add_3_op1, strobe_32b, subop_add_7_op3, subop_add_7_op2, subop_add_5_op1, subop_add_7_op1, aldu8_op1, lsu_registers_32_1_glockreq_out, ast8_op2, ast8_op3, subop_add_2_op3, subop_add_3_op2, ald16_op2, subop_st8_0_op2, lsu_registers_32_1_rready_out, load_in1t_in, ast32_op1, subop_add_0_op2, rdata_in, lsu_registers_32_1_aaddr_out, lsu_registers_32_1_awren_out, ast16_op3, subop_add_1_op2, lsu_registers_32_1_adata_out, load_data_32b, aready_in, lsu_registers_32_1_astrb_out, ast16_op1, rvalid_in, lsu_registers_32_1_avalid_out, ald8_op2, lsu_registers_32_1_rdata_out, subop_add_2_op1, subop_st8_0_op1, aldu16_op2, subop_add_6_op3, subop_st16_0_op1, aldu8_op2, subop_add_4_op2, subop_ld16_0_op1, ast8_op1, ald32_op1, subop_st32_0_op1, subop_ld32_0_op1, subop_ldu16_0_op1, ald32_op2, subop_add_4_op1, subop_add_2_op2, optrig_2_r, ald16_op1, subop_ldu8_0_op1, ald8_op1, subop_ld8_0_op1, aldu16_op1)
  begin
    aaddr_out <= (others => '0');
    adata_out <= (others => '0');
    astrb_out <= (others => '0');
    avalid_out <= (others => '0');
    awren_out <= (others => '0');
    rready_out <= (others => '0');
    lsu_registers_32_1_clk <= '0';
    lsu_registers_32_1_rstx <= '0';
    lsu_registers_32_1_glock_in <= '0';
    lsu_registers_32_1_avalid_in <= '0';
    lsu_registers_32_1_awren_in <= '0';
    lsu_registers_32_1_aaddr_in <= (others => '0');
    lsu_registers_32_1_astrb_in <= (others => '0');
    lsu_registers_32_1_adata_in <= (others => '0');
    lsu_registers_32_1_aready_in <= '0';
    lsu_registers_32_1_rvalid_in <= '0';
    lsu_registers_32_1_rdata_in <= (others => '0');
    strobe_32b <= (others => '0');
    write_data_32b <= (others => '0');
    load_data_32b <= (others => '0');
    subop_st8_0_op1 <= subop_add_7_op3;
    subop_st8_0_op2 <= ast8_op3(7 downto 0);
    subop_add_7_op3 <= (others => '0');
    subop_add_7_op1 <= ast8_op1;
    subop_add_7_op2 <= ast8_op2;
    subop_st32_0_op1 <= ((64-1 downto 32 => '0') & subop_add_6_op3);
    subop_st32_0_op2 <= ast32_op3;
    ast16_op1 <= data_in1t;
    ast16_op2 <= data_in2;
    ast16_op3 <= data_in3;
    subop_st16_0_op1 <= subop_add_5_op3;
    subop_st16_0_op2 <= ast16_op3(15 downto 0);
    ast32_op1 <= data_in1t;
    ast32_op2 <= data_in2;
    ast32_op3 <= data_in3;
    subop_add_5_op3 <= (others => '0');
    subop_add_5_op1 <= ast16_op1;
    subop_add_5_op2 <= ast16_op2;
    aldu8_op3 <= (others => '0');
    aldu8_op1 <= data_in1t;
    aldu8_op2 <= data_in2;
    aldu8_op3 <= subop_ldu8_0_op2;
    subop_add_0_op3 <= (others => '0');
    subop_add_0_op1 <= ald16_op1;
    subop_add_0_op2 <= ald16_op2;
    subop_add_1_op3 <= (others => '0');
    subop_add_1_op1 <= ald32_op1;
    subop_add_1_op2 <= ald32_op2;
    subop_ld16_0_op2 <= (others => '0');
    subop_ld16_0_op1 <= ((64-1 downto 32 => '0') & subop_add_0_op3);
    ast8_op1 <= data_in1t;
    ast8_op2 <= data_in2;
    ast8_op3 <= data_in3;
    subop_add_4_op3 <= (others => '0');
    subop_add_4_op1 <= aldu8_op1;
    subop_add_4_op2 <= aldu8_op2;
    subop_ld32_0_op2 <= (others => '0');
    subop_ld32_0_op1 <= ((64-1 downto 32 => '0') & subop_add_1_op3);
    subop_ldu16_0_op2 <= (others => '0');
    subop_ldu16_0_op1 <= ((64-1 downto 32 => '0') & subop_add_3_op3);
    ald32_op3 <= (others => '0');
    ald32_op1 <= data_in1t;
    ald32_op2 <= data_in2;
    ald32_op3 <= subop_ld32_0_op2;
    subop_add_2_op3 <= (others => '0');
    subop_add_2_op1 <= ald8_op1;
    subop_add_2_op2 <= ald8_op2;
    subop_ldu8_0_op2 <= (others => '0');
    subop_ldu8_0_op1 <= ((64-1 downto 32 => '0') & subop_add_4_op3);
    ald8_op3 <= (others => '0');
    ald8_op1 <= data_in1t;
    ald8_op2 <= data_in2;
    ald8_op3 <= subop_ld8_0_op2;
    subop_add_6_op3 <= (others => '0');
    subop_add_6_op1 <= ast32_op1;
    subop_add_6_op2 <= ast32_op2;
    subop_ld8_0_op2 <= (others => '0');
    subop_ld8_0_op1 <= ((64-1 downto 32 => '0') & subop_add_2_op3);
    aldu16_op3 <= (others => '0');
    aldu16_op1 <= data_in1t;
    aldu16_op2 <= data_in2;
    aldu16_op3 <= subop_ldu16_0_op2;
    ald16_op3 <= (others => '0');
    ald16_op1 <= data_in1t;
    ald16_op2 <= data_in2;
    ald16_op3 <= subop_ld16_0_op2;
    subop_add_3_op3 <= (others => '0');
    subop_add_3_op1 <= aldu16_op1;
    subop_add_3_op2 <= aldu16_op2;
    glockreq <= '0';
    lsu_registers_32_1_avalid_in <= '0';
    lsu_registers_32_1_awren_in <= '0';
    lsu_registers_32_1_aaddr_in <= (others => '0');
    lsu_registers_32_1_astrb_in <= (others => '0');
    lsu_registers_32_1_adata_in <= (others => '0');
    
    avalid_out(0) <= lsu_registers_32_1_avalid_out;
    lsu_registers_32_1_aready_in <= aready_in(0);
    aaddr_out <= lsu_registers_32_1_aaddr_out;
    awren_out(0) <= lsu_registers_32_1_awren_out;
    astrb_out <= lsu_registers_32_1_astrb_out;
    adata_out <= lsu_registers_32_1_adata_out;
    
    lsu_registers_32_1_rvalid_in <= rvalid_in(0);
    rready_out(0) <= lsu_registers_32_1_rready_out;
    lsu_registers_32_1_rdata_in <= rdata_in;
    
    glockreq <= lsu_registers_32_1_glockreq_out;
    if (load_in1t_in = '1') then
      case operation_in is
        when op_ald16_c =>
          subop_add_0_op3 <= std_logic_vector(signed(subop_add_0_op1) + signed(subop_add_0_op2));
          lsu_registers_32_1_avalid_in <= '1';
          lsu_registers_32_1_aaddr_in <= subop_ld16_0_op1(addrw_c-1 downto 0);
          lsu_registers_32_1_awren_in <= '0';
        when op_ald32_c =>
          subop_add_1_op3 <= std_logic_vector(signed(subop_add_1_op1) + signed(subop_add_1_op2));
          lsu_registers_32_1_avalid_in <= '1';
          lsu_registers_32_1_aaddr_in <= subop_ld32_0_op1(addrw_c-1 downto 0);
          lsu_registers_32_1_awren_in <= '0';
        when op_ald8_c =>
          subop_add_2_op3 <= std_logic_vector(signed(subop_add_2_op1) + signed(subop_add_2_op2));
          lsu_registers_32_1_avalid_in <= '1';
          lsu_registers_32_1_aaddr_in <= subop_ld8_0_op1(addrw_c-1 downto 0);
          lsu_registers_32_1_awren_in <= '0';
        when op_aldu16_c =>
          subop_add_3_op3 <= std_logic_vector(signed(subop_add_3_op1) + signed(subop_add_3_op2));
          lsu_registers_32_1_avalid_in <= '1';
          lsu_registers_32_1_aaddr_in <= subop_ldu16_0_op1(addrw_c-1 downto 0);
          lsu_registers_32_1_awren_in <= '0';
        when op_aldu8_c =>
          subop_add_4_op3 <= std_logic_vector(signed(subop_add_4_op1) + signed(subop_add_4_op2));
          lsu_registers_32_1_avalid_in <= '1';
          lsu_registers_32_1_aaddr_in <= subop_ldu8_0_op1(addrw_c-1 downto 0);
          lsu_registers_32_1_awren_in <= '0';
        when op_ast16_c =>
          subop_add_5_op3 <= std_logic_vector(signed(subop_add_5_op1) + signed(subop_add_5_op2));
          lsu_registers_32_1_avalid_in <= '1';
          lsu_registers_32_1_awren_in <= '1';
          lsu_registers_32_1_aaddr_in <= subop_st16_0_op1(addrw_c-1 downto 0);
          strobe_32b <= "0000";
          write_data_32b <= "00000000000000000000000000000000";
          case subop_st16_0_op1(1 downto 1) is
            when "0" => 
              strobe_32b(1 downto 0) <= "11";
              write_data_32b(15 downto 0) <= subop_st16_0_op2;
            when others => 
              strobe_32b(3 downto 2) <= "11";
              write_data_32b(31 downto 16) <= subop_st16_0_op2;
          end case;
          lsu_registers_32_1_adata_in <= write_data_32b;
          lsu_registers_32_1_astrb_in <= strobe_32b;
        when op_ast32_c =>
          subop_add_6_op3 <= std_logic_vector(signed(subop_add_6_op1) + signed(subop_add_6_op2));
          lsu_registers_32_1_avalid_in <= '1';
          lsu_registers_32_1_awren_in <= '1';
          lsu_registers_32_1_aaddr_in <= subop_st32_0_op1(addrw_c-1 downto 0);
          lsu_registers_32_1_adata_in <= subop_st32_0_op2;
          lsu_registers_32_1_astrb_in <= "1111";
        when op_ast8_c =>
          subop_add_7_op3 <= std_logic_vector(signed(subop_add_7_op1) + signed(subop_add_7_op2));
          lsu_registers_32_1_avalid_in <= '1';
          lsu_registers_32_1_awren_in <= '1';
          lsu_registers_32_1_aaddr_in <= subop_st8_0_op1(addrw_c-1 downto 0);
          strobe_32b <= "0000";
          write_data_32b <= "00000000000000000000000000000000";
          case subop_st8_0_op1(1 downto 0) is
            when "00" => 
              strobe_32b(0 downto 0) <= "1";
              write_data_32b(7 downto 0) <= subop_st8_0_op2;
            when "01" => 
              strobe_32b(1 downto 1) <= "1";
              write_data_32b(15 downto 8) <= subop_st8_0_op2;
            when "10" => 
              strobe_32b(2 downto 2) <= "1";
              write_data_32b(23 downto 16) <= subop_st8_0_op2;
            when others => 
              strobe_32b(3 downto 3) <= "1";
              write_data_32b(31 downto 24) <= subop_st8_0_op2;
          end case;
          lsu_registers_32_1_adata_in <= write_data_32b;
          lsu_registers_32_1_astrb_in <= strobe_32b;
        when others =>
      end case;
    end if;
    if (optrig_2_r = '1') then
      case operation_2_r is
        when op_ald16_c =>
          load_data_32b <= lsu_registers_32_1_rdata_out;
          case lsu_registers_32_1_addr_low_out(1 downto 1) is
            when "0" => subop_ld16_0_op2 <= (16-1 downto 0 => load_data_32b(15)) & load_data_32b(15 downto 0);
            when others => subop_ld16_0_op2 <= (16-1 downto 0 => load_data_32b(31)) & load_data_32b(31 downto 16);
          end case;
        when op_ald32_c =>
          load_data_32b <= lsu_registers_32_1_rdata_out;
          subop_ld32_0_op2 <= load_data_32b;
        when op_ald8_c =>
          load_data_32b <= lsu_registers_32_1_rdata_out;
          case lsu_registers_32_1_addr_low_out(1 downto 0) is
            when "00" => subop_ld8_0_op2 <= (24-1 downto 0 => load_data_32b(7)) & load_data_32b(7 downto 0);
            when "01" => subop_ld8_0_op2 <= (24-1 downto 0 => load_data_32b(15)) & load_data_32b(15 downto 8);
            when "10" => subop_ld8_0_op2 <= (24-1 downto 0 => load_data_32b(23)) & load_data_32b(23 downto 16);
            when others => subop_ld8_0_op2 <= (24-1 downto 0 => load_data_32b(31)) & load_data_32b(31 downto 24);
          end case;
        when op_aldu16_c =>
          load_data_32b <= lsu_registers_32_1_rdata_out;
          case lsu_registers_32_1_addr_low_out(1 downto 1) is
            when "0" => subop_ldu16_0_op2 <= "0000000000000000" & load_data_32b(15 downto 0);
            when others => subop_ldu16_0_op2 <= "0000000000000000" & load_data_32b(31 downto 16);
          end case;
        when op_aldu8_c =>
          load_data_32b <= lsu_registers_32_1_rdata_out;
          case lsu_registers_32_1_addr_low_out(1 downto 0) is
            when "00" => subop_ldu8_0_op2 <= "000000000000000000000000" & load_data_32b(7 downto 0);
            when "01" => subop_ldu8_0_op2 <= "000000000000000000000000" & load_data_32b(15 downto 8);
            when "10" => subop_ldu8_0_op2 <= "000000000000000000000000" & load_data_32b(23 downto 16);
            when others => subop_ldu8_0_op2 <= "000000000000000000000000" & load_data_32b(31 downto 24);
          end case;
        when others =>
      end case;
    end if;
  end process operations_actual_cp;

  output_pipeline_sp : process(clk, rstx)
  begin
    if rstx = '0' then
      data_out1_r <= (others => '0');
    elsif clk = '1' and clk'event then
      if (glock_in = '0') then
        data_out1_r <= data_out1;
      end if;
    end if;
  end process output_pipeline_sp;

  output_pipeline_cp : process(data_out1, aldu16_op3, operation_2_r, aldu8_op3, data_out1_r, optrig_2_r, ald8_op3, ald32_op3, ald16_op3)
  begin
    if ((operation_2_r = op_aldu8_c) and (optrig_2_r = '1')) then
      data_out1 <= aldu8_op3;
    elsif ((operation_2_r = op_aldu16_c) and (optrig_2_r = '1')) then
      data_out1 <= aldu16_op3;
    elsif ((operation_2_r = op_ald8_c) and (optrig_2_r = '1')) then
      data_out1 <= ald8_op3;
    elsif ((operation_2_r = op_ald32_c) and (optrig_2_r = '1')) then
      data_out1 <= ald32_op3;
    elsif ((operation_2_r = op_ald16_c) and (optrig_2_r = '1')) then
      data_out1 <= ald16_op3;
    else
      data_out1 <= data_out1_r;
    end if;
    data_out1_out <= data_out1;
  end process output_pipeline_cp;
  glockreq_out <= glockreq;

end architecture rtl;

